#!/usr/bin/python3.7
import yaml, pandas as pd, math, re, argparse
from textwrap import dedent
import ventos_yaml as vy
import io, os

auto_generated_notice = "NOTICE: do not edit this file it is autogenerated"

def snake_to_title(key):
    return key.replace('_', ' ').title()

# create a anchor_name just by joining a list eg [state, peep] => state_peep
anchor_name = lambda i : "_".join(i)
# create a HTML anchor
markdown_anchor = lambda i : f'<a name="{anchor_name(i)}"></a>'
# create a markdown anchor using the last item in the list as the label
markdown_link = lambda k : f'[{k[-1]}](#{anchor_name(k)})'

# take a dictionary raw data from source files and decorate
# This function does the common pre-processing of YAML.
def meta_to_dataframes(yaml_data, pretty = False):
    dfs = {}
    for chapter, meta in yaml_data.items():
        meta_meta = vy.META_ITEMS[chapter]
        cols = {**meta_meta['required'], **meta_meta['optional']}
        df = pd.DataFrame.from_dict(meta, orient='index',  columns=cols)
        # modify the data-frame to make it prettier and add links and achnors
        if chapter == 'state':
            # make a pretty cell
            # calculate precision
            df['significant_digits'] = [(max(0, -round(math.log10(r.resolution)))
                    if vy.is_number(r.resolution) else 0)
                    for r in df.itertuples()]
            df['values'] = [vy.pretty_values(r) for r in df.itertuples()]
            df['c_type'] = [vy.c_type(r) for r in df.itertuples()]
            # create a list of alarms this property links to
            df['alarms'] = [
                    ', '.join([f"[{k}](#{anchor_name(['alarm', k])})" for k in yaml_data['alarm'].keys()
                                 if re.match(f"{r.Index}_[A-Z]*", k)])
                    for r in df.itertuples()]
            if pretty: # drop the ugly columns
                range_cols = ['min', 'max', 'units', 'enum', 'default', 'significant_digits', 'resolution']
                df.drop(range_cols, axis=1, inplace=True)
        elif chapter == 'alarm':
            # link back to the alarm state
            df['state'] = [markdown_link(['state', vy.alarm_to_state(r.Index)]) for r in df.itertuples()]
            # links to state and join the units fields
            df['units'] = [
                    yaml_data['state'][vy.alarm_to_state(r.Index)]['units']
                    for r in df.itertuples()]
        # main table
        df['key'] = [markdown_anchor([chapter, r.Index]) for r in df.itertuples()]
        dfs[chapter] = df
    return dfs

#
def make_md(yaml_data):
    dfs = meta_to_dataframes(yaml_data, pretty = True)
    md = []
    md.append(dedent(f"""
    <!-- {auto_generated_notice} ->
    # <a name='top'></a>Introduction
    This is human readable the contents of the draft VentOS meta database.

    Using YAML files committed git repositories the VentOS project is able to
    control changes.

    Use source source YAML files as the source of truth.
    """))

    # header bar
    md.append(" | ".join([f"*[{snake_to_title(c)}](#{c})*" for c in yaml_data.keys()]))
    for chapter, df in dfs.items():
        meta_meta = vy.META_ITEMS[chapter]
        # title
        md.append(f'\n# {markdown_anchor([chapter])}{snake_to_title(chapter)} '
              f'({len(df)} items)')
        # menu bar
        md.append(" | ".join([markdown_link([chapter, k]) for k in df.index]))
        # main table
        df['key'] = [markdown_anchor([chapter, r.Index]) for r in df.itertuples()]
        md.append(df.to_markdown(showindex=True))
        md.append('\n[[top]](#top)')
    return '\n'.join(md)

def make_c(yaml_data):
    dfs = meta_to_dataframes(yaml_data, pretty = False)
    state_vars ="\n"+ "\n".join(
            [f"      {r.c_type} {r.Index};"
                for r in dfs['state'].itertuples()])
    # note use of {{double curlies}} to escape {} in python f"string"
    c = dedent(f"""
    // {auto_generated_notice}
    struct state
    {{{state_vars}
    }};
    """)
    return c

allowed_jobs = ['C', 'Markdown', 'All']

def main(args):
    # manage verbosity of debug and progress messages
    script_verbosity = args.get('verbose', 0)
    def chat(text, message_verbosity):
        # higher message_verbosity messages not printed
        if message_verbosity <= script_verbosity:
            print(text)
    # save the results to a file, or print depending on mode
    def write(job, text, outdir, outfile):
        if outdir:
            outfile = os.path.join(outdir, outfile)
            with open(outfile, 'w') as f:
                f.write(text)
            chat(f'## {job} complete', 1)
            chat(f'  - {len(text)} bytes written to {outfile}', 1)
        else:
            print(text)
    chat(f"Arguments in: {args}",2)
    yaml_data = vy.load_yaml(args['sourcedir'])
    outdir = args.get('outdir', False)
    lower_allowed_jobs = list(map(str.lower, allowed_jobs))
    lower_allowed_jobs.remove('all')
    lower_jobs_in = list(map(str.lower, args['job']))
    # if jobs includes all, add all the jobs to the list
    jobs_todo = lower_allowed_jobs if 'all' in lower_jobs_in else lower_jobs_in
    chat(f'Jobs todo: {jobs_todo}', 2)
    for job in jobs_todo:
        if job == 'markdown':
            write('Markdown', make_md(yaml_data), outdir, 'index.md')
        elif job == 'c':
            write('C', make_c(yaml_data), outdir, 'test.c')
        else:
            raise ValueError(f"unknown job {job}")

if __name__ == "__main__":
    # setup command line arguements
    parser = argparse.ArgumentParser(
            description='VentOS YAML packager')
    parser.add_argument('-j', '--job', action="append",
            default=[], help=f"{allowed_jobs}")
    parser.add_argument('-s', '--sourcedir', action="store",
            default=vy.DICTIONARY_PATH,
            help='source directory for YAML files')
    parser.add_argument('-o', '--outdir', action="store",
            default=False,
            help='output directory (prints to stdout if none supplied')
    parser.add_argument('--verbose', '-v', action='count',
            default=0,
            help='Verbosity')
    main(vars(parser.parse_args()))

