#!/usr/bin/python3.7
"""Package script for transforming YAML files to alternative formats"""
import re
import argparse
import math
import os
from textwrap import dedent
import pandas as pd
from make_c import make_state_struct, make_all_module_stubs
import ventos_yaml as vy

AUTO_GENERATED_NOTICE = "NOTICE: do not edit this file it is autogenerated"


def snake_to_title(key):
    """ Take a snake_string and "Make It Pretty" """
    return key.replace('_', ' ').title()


def anchor_name(key_list):
    """ create a anchor_name just by joining a list eg [state, peep] => state_peep """
    return "_".join(key_list)


def markdown_anchor(key_list):
    """ create a HTML anchor """
    return f'<a name="{anchor_name(key_list)}"></a>'


def markdown_link(key_list):
    """ Create a markdown anchor using the last item in the list as the label """
    return f'[{key_list[-1]}](#{anchor_name(key_list)})'


def meta_to_dataframes(yaml_data, pretty=False):
    """
    Take a dictionary raw data from source files and decorate
    doing the common pre-processing of YAML.
    """
    dfs = {}
    for chapter, meta in yaml_data.items():
        meta_meta = vy.META_META[chapter]
        cols = {**meta_meta['required'], **meta_meta['optional']}
        # chapter dataframe
        cdf = pd.DataFrame.from_dict(meta, orient='index', columns=cols)
        # modify the data-frame to make it prettier and add links and achnors
        if chapter == 'state':
            # make a pretty cell
            # calculate precision
            cdf['significant_digits'] = [
                (max(0, -round(math.log10(rec.resolution)))
                 if vy.is_number(rec.resolution) else 0)
                for rec in cdf.itertuples()
            ]
            cdf['values'] = [vy.pretty_values(rec) for rec in cdf.itertuples()]
            cdf['c_type'] = [vy.c_type(rec) for rec in cdf.itertuples()]
            # create a list of alarms this property links to
            cdf['alarms'] = [
                ', '.join([
                    f"[{key}](#{anchor_name(['alarm', key])})"
                    for key in yaml_data['alarm'].keys()
                    if re.match(f"{rec.Index}_[A-Z]*", key)
                ]) for rec in cdf.itertuples()
            ]
            if pretty:  # drop the ugly columns
                range_cols = [
                    'min', 'max', 'units', 'enum', 'default',
                    'significant_digits', 'resolution'
                ]
                cdf.drop(range_cols, axis=1, inplace=True)
        elif chapter == 'alarm':
            # link back to the alarm state
            cdf['state'] = [
                markdown_link(['state', vy.alarm_to_state(rec.Index)])
                for rec in cdf.itertuples()
            ]
            # links to state and join the units fields
            cdf['units'] = [
                yaml_data['state'][vy.alarm_to_state(rec.Index)]['units']
                for rec in cdf.itertuples()
            ]
        # main table
        cdf['key'] = [
            markdown_anchor([chapter, rec.Index]) for rec in cdf.itertuples()
        ]
        dfs[chapter] = cdf
    return dfs


def make_md(yaml_data):
    """ Convert all the YAML as a markdown string """
    dfs = meta_to_dataframes(yaml_data, pretty=True)
    markdown = []
    markdown.append(
        dedent(f"""
    <!-- {AUTO_GENERATED_NOTICE} -->
    # <a name='top'></a>Introduction
    This is human readable the contents of the draft VentOS meta database.

    Using YAML files committed git repositories the VentOS project is able to
    control changes.

    Use source source YAML files as the source of truth.
    """))

    # header bar
    markdown.append(" | ".join(
        [f"*[{snake_to_title(key)}](#{key})*" for key in yaml_data.keys()]))
    for chapter, cdf in dfs.items():
        # title
        markdown.append(f'\n# {markdown_anchor([chapter])}{snake_to_title(chapter)} '
                        f'({len(cdf)} items)')
        # menu bar
        markdown.append(" | ".join([markdown_link([chapter, k]) for k in cdf.index]))
        # main table
        cdf['key'] = [
            markdown_anchor([chapter, r.Index]) for r in cdf.itertuples()
        ]
        markdown.append(cdf.to_markdown(index=True))
        markdown.append('\n[[top]](#top)')
    return '\n'.join(markdown)


def make_c(core_meta_dfs):
    """ Make C files from yaml. Currently returns text, but that will need to change."""
    c_text = f"""// {AUTO_GENERATED_NOTICE}
    {make_state_struct(core_meta_dfs)}
    {make_all_module_stubs(core_meta_dfs)}
    """
    return c_text


ALLOWED_JOBS = ['C', 'Markdown', 'All']


def main(args):
    """Main function that handles command line arguments etc"""

    # Manage verbosity of debug and progress messages
    script_verbosity = args.get('verbose', 0)

    def chat(text, message_verbosity):
        # higher message_verbosity messages not printed
        if message_verbosity <= script_verbosity:
            print(text)

    # save the results to a file, or print depending on mode
    def write(job, text, outdir, outfile):
        if outdir:
            outfile = os.path.join(outdir, outfile)
            with open(outfile, 'w') as stream:
                stream.write(text)
            chat(f'## {job} complete', 1)
            chat(f'  - {len(text)} bytes written to {outfile}', 1)
        else:
            print(text)

    chat(f"Arguments in: {args}", 2)
    core_yaml = vy.load_yaml(args['sourcedir'])
    outdir = args.get('outdir', False)
    lower_allowed_jobs = list(map(str.lower, ALLOWED_JOBS))
    lower_allowed_jobs.remove('all')
    lower_jobs_in = list(map(str.lower, args['job']))
    # if jobs includes all, add all the jobs to the list
    jobs_todo = lower_allowed_jobs if 'all' in lower_jobs_in else lower_jobs_in
    chat(f'Jobs todo: {jobs_todo}', 2)
    if len(jobs_todo) == 0:
        raise ValueError(f"No jobs supplied")
    for job in jobs_todo:
        if job == 'markdown':
            write('Markdown', make_md(core_yaml), outdir, 'index.md')
        elif job == 'c':
            core_meta_dfs = meta_to_dataframes(core_yaml, pretty=False)
            write('C', make_c(core_meta_dfs), outdir, 'auto_kernel.c')
        else:
            raise ValueError(f"Unknown job {job}")


if __name__ == "__main__":
    # setup command line arguements
    PARSER = argparse.ArgumentParser(description='VentOS YAML packager')
    PARSER.add_argument('-j',
                        '--job',
                        action="append",
                        default=[],
                        help=f"{ALLOWED_JOBS}")
    PARSER.add_argument('-s',
                        '--sourcedir',
                        action="store",
                        default=vy.DICTIONARY_PATH,
                        help='source directory for YAML files')
    PARSER.add_argument(
        '-o',
        '--outdir',
        action="store",
        default=False,
        help='output directory (prints to stdout if none supplied')
    PARSER.add_argument('--verbose',
                        '-v',
                        action='count',
                        default=0,
                        help='Verbosity')
    main(vars(PARSER.parse_args()))
